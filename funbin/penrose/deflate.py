"""
Penrose (and potentially other) tilings, generated by successive deflation of tiles.
Code adapted from [1].

[1] https://pcwww.liv.ac.uk/~hemraj/thesis/BSc/2021_Daniel_Gouldsbrough_BSc_Thesis.pdf
"""

from dataclasses import dataclass
from typing import Sequence

import numpy as np

from funbin.geometry import LineSegment, Point, Polygon


@dataclass
class Tile:
    name: str
    points: Sequence[Point]

    def rotated(self, angle_deg: float) -> "Tile":
        # Rotates each vertex of any 4 sided tile anticlockwise
        # by given angle in degrees about (0,0).
        # This is used to generate the initial star which will be deflated.
        return Tile(
            name=self.name,
            points=[point.rotated(deg(angle_deg)) for point in self.points],
        )

    def rounded_center(self, ndigits: int = 9) -> Point:
        center = self.as_polygon().centroid
        return Point(
            x=round(center.x, ndigits=ndigits),
            y=round(center.y, ndigits=ndigits),
        )

    def as_polygon(self) -> Polygon:
        return Polygon.from_points(self.points)


def tile(name: str, *points: Point) -> Tile:
    """Helper function to convert"""
    return Tile(name, points)


golden_ratio = (1 + np.sqrt(5)) / 2

deg = np.deg2rad


kite: list[Tile] = [
    Tile(
        name="kite",
        points=[Point(0, 0), Point(0, 1).rotated(deg(-36)), Point(0, 1), Point(0, 1).rotated(deg(36))],
    )
]
dart: list[Tile] = [
    Tile(
        name="dart",
        points=[Point(0, 0), Point(0, 1).rotated(deg(-36)), Point(0, 1 / golden_ratio), Point(0, 1).rotated(deg(36))],
    )
]

sun = [  # 5 kites at angles of 72 degrees from each other, forming a decagon
    kite[0],
    kite[0].rotated(72),
    kite[0].rotated(144),
    kite[0].rotated(216),
    kite[0].rotated(288),
]
starP2 = [  # 5 darts at angles of 72 degrees from each other, forming a 5 pointed star
    dart[0],
    dart[0].rotated(72),
    dart[0].rotated(144),
    dart[0].rotated(216),
    dart[0].rotated(288),
]

fat: list[Tile] = [
    Tile(
        name="fat",
        points=[Point(0, 0), Point(1, 0), Point(1, 0).rotated(deg(72)) + Point(1, 0), Point(1, 0).rotated(deg(72))],
    ),
]
thin: list[Tile] = [
    Tile(
        name="thin",
        points=[Point(0, 0), Point(1, 0), Point(1, 0).rotated(deg(36)) + Point(1, 0), Point(1, 0).rotated(deg(36))],
    )
]

starP3 = [  # 5 fat rhombs at angles of 72 degrees from each other, forming a star
    fat[0],
    fat[0].rotated(72),
    fat[0].rotated(144),
    fat[0].rotated(216),
    fat[0].rotated(288),
]
square: list[Tile] = [
    Tile(
        "square",
        [Point(0, 0), Point(1, 0), Point(1, 1), Point(0, 1)],
    ),
]
triangle: list[Tile] = [
    Tile(
        "triangle",
        [Point(0, 0), Point(1, 0), Point(1, 0).rotated(deg(60))],
    )
]
sierpinski = [
    Tile(
        name="sierpinski",
        points=[Point(0, 0), Point(1, 0), Point(1, 0).rotated(deg(60))],
    )
]
hexagon = [
    Tile(
        name="hexagon",
        points=[
            Point(0, 0),
            Point(1, 0),
            Point(1, 0).rotated(deg(60)) + Point(1, 0),
            Point(1, np.sqrt(3)),
            Point(0, np.sqrt(3)),
            Point(1, 0).rotated(120),
        ],
    )
]
chair = [
    Tile(
        name="chair",
        points=[Point(2, 2), Point(2, 4), Point(0, 4), Point(0, 0), Point(4, 0), Point(4, 2)],
    )
]
rhombA5 = [
    Tile(
        name="rhombA5",
        points=[Point(0, 0), Point(1, 0), Point(1, 0).rotated(deg(45)) + Point(1, 0), Point(1, 0).rotated(deg(45))],
    )
]

starA5 = [
    rhombA5[0],
    rhombA5[0].rotated(45),
    rhombA5[0].rotated(90),
    rhombA5[0].rotated(135),
    rhombA5[0].rotated(180),
    rhombA5[0].rotated(225),
    rhombA5[0].rotated(270),
    rhombA5[0].rotated(315),
]
pent1 = [
    Tile(
        name="pent1",
        points=[
            Point(0, 0),
            Point(1, 0),
            Point(1, 0).rotated(deg(72)) + Point(1, 0),
            Point(0.5, np.sqrt(5 + 2 * np.sqrt(5)) / 2),
            Point(1, 0).rotated(deg(108)),
        ],
    )
]


def deflate_kite(kite: Tile) -> list[Tile]:
    # Deflation process for kite tiles, returns 4 new smaller tiles (2 kites and 2 darts).
    A = kite.points[0]
    B = kite.points[1]
    C = kite.points[2]
    D = kite.points[3]
    e = (C - A) / golden_ratio + A
    f = (A - B) / golden_ratio + B
    g = (A - D) / golden_ratio + D
    h = A + B - e
    i = A + D - e
    return [
        tile("kite", B, C, e, f),
        tile("kite", D, g, e, C),
        tile("dart", A, e, g, i),
        tile("dart", A, h, f, e),
    ]


def deflate_dart(dart: Tile) -> list[Tile]:
    # Deflation process for dart tiles, returns 3 new smaller tiles (1 kite and 2 darts)
    A = dart.points[0]
    B = dart.points[1]
    C = dart.points[2]
    D = dart.points[3]
    e = (B - A) / golden_ratio + A
    f = (D - A) / golden_ratio + A
    g = A + B - C
    h = A + D - C
    return [tile("kite", A, e, C, f), tile("dart", B, C, e, g), tile("dart", D, h, f, C)]


def deflate_fat(fat: Tile) -> list[Tile]:
    # Deflation process for fat rhombs, returns 5 new smaller rhombs (2 thin and 3 fat).
    A = fat.points[0]
    B = fat.points[1]
    C = fat.points[2]
    D = fat.points[3]
    e = (B - A) / golden_ratio + A
    f = (C - A) / golden_ratio + A
    g = (D - A) / golden_ratio + A
    h = B + e - f
    i = B + C - f
    j = C + D - f
    k = D + g - f
    return [
        tile("fat", f, g, A, e),
        tile("thin", h, B, f, e),
        tile("fat", C, f, B, i),
        tile("fat", C, j, D, f),
        tile("thin", f, D, k, g),
    ]


def deflate_thin(thin: Tile) -> list[Tile]:
    # Deflation process for thin rhombs, returns 4 new smaller rhombs (2 thin and 2 fat).
    A = thin.points[0]
    B = thin.points[1]
    C = thin.points[2]
    D = thin.points[3]
    e = (D - A) / golden_ratio + A
    f = (D - C) / golden_ratio + C
    g = D + e - B
    h = A + B - e
    i = D + f - B
    j = B + C - f
    return [
        tile("fat", B, e, A, h),
        tile("thin", B, D, g, e),
        tile("thin", i, D, B, f),
        tile("fat", B, j, C, f),
    ]


def deflate_square(square: Tile) -> list[Tile]:
    # Deflation process for squares, returns 4 new smaller squares
    A = square.points[0]
    B = square.points[1]
    C = square.points[2]
    D = square.points[3]
    e = (A + B) / 2
    f = (B + C) / 2
    g = (C + D) / 2
    h = (D + A) / 2
    i = (A + C) / 2
    return [
        tile("square", A, e, i, h),
        tile("square", e, B, f, i),
        tile("square", i, f, C, g),
        tile("square", h, i, g, D),
    ]


def deflate_triangle(triangle: Tile) -> list[Tile]:
    # Deflation process for triangles, returns 4 new smaller squares
    A = triangle.points[0]
    B = triangle.points[1]
    C = triangle.points[2]
    e = (A + B) / 2
    f = (B + C) / 2
    g = (C + A) / 2
    return [
        tile("triangle", A, e, g),
        tile("triangle", e, B, f),
        tile("triangle", g, f, C),
        tile("triangle", e, f, g),
    ]


def deflate_sierpinski(sierpinski: Tile) -> list[Tile]:
    # Deflation process for squares, returns 4 new smaller squares
    A = sierpinski.points[0]
    B = sierpinski.points[1]
    C = sierpinski.points[2]
    e = (A + B) / 2
    f = (B + C) / 2
    g = (C + A) / 2
    return [
        tile("sierpinski", A, e, g),
        tile("sierpinski", e, B, f),
        tile("sierpinski", g, f, C),
    ]


def deflate_hexagon(hexagon: Tile) -> list[Tile]:
    # Deflation process for squares, returns 4 new smaller squares
    A = hexagon.points[0]
    B = hexagon.points[1]
    C = hexagon.points[2]
    D = hexagon.points[3]
    E = hexagon.points[4]
    F = hexagon.points[5]
    cen = (A + D) / 2
    g = 2 * A - cen
    h = 2 * B - cen
    i = 2 * C - cen
    j = 2 * D - cen
    k = 2 * E - cen
    l = 2 * F - cen
    return [
        tile("hexagon", A, B, C, D, E, F),
        tile("hexagon", 2 * A - E, 2 * B - D, h, B, A, g),
        tile("hexagon", h, 2 * B - F, 2 * C - E, i, C, B),
        tile("hexagon", C, i, 2 * C - A, 2 * D - F, j, D),
        tile("hexagon", E, D, j, 2 * D - B, 2 * E - A, k),
        tile("hexagon", l, F, E, k, 2 * E - C, 2 * F - B),
        tile("hexagon", 2 * A - C, g, A, F, l, 2 * F - D),
    ]


def deflate_chair(chair: Tile) -> list[Tile]:
    # Deflates given single chair into 4 smaller chairs
    A = chair.points[0]
    B = chair.points[1]
    C = chair.points[2]
    D = chair.points[3]
    E = chair.points[4]
    F = chair.points[5]
    r = (A + B) / 2
    s = (C + D) / 2
    t = (D + E) / 2
    u = (A + F) / 2
    v = (3 * C + D + 2 * A + 2 * B) / 8
    w = (2 * A + 4 * D + C + E) / 8
    x = (2 * A + 2 * F + D + 3 * E) / 8
    y = (2 * A + C + D) / 4
    z = (2 * A + D + E) / 4
    return [
        tile(
            "chair",
            A,
            r,
            v,
            w,
            x,
            u,
        ),
        tile("chair", v, r, B, C, s, y),
        tile("chair", w, y, s, D, t, z),
        tile("chair", x, z, t, E, F, u),
    ]


silvRatio = 1 + np.sqrt(2)
# Silver ratio, used in A5 tiling


def deflate_rhombA5(rhombA5: Tile) -> list[Tile]:
    A = rhombA5.points[0]
    B = rhombA5.points[1]
    C = rhombA5.points[2]
    D = rhombA5.points[3]
    e = (C - A) / silvRatio + A
    f = (A - C) / silvRatio + C
    g = (B - A) / silvRatio + A
    h = (B - C) / silvRatio + C
    i = (D - C) / silvRatio + C
    j = (D - A) / silvRatio + A
    k = B + g - e
    l = B + h - f
    m = D + i - f
    n = D + j - e
    return [
        tile("rhombA5", A, g, e, j),
        tile("rhombA5", D, e, B, f),
        tile("rhombA5", C, i, f, h),
        tile("squareA5", B, e, g, k),
        tile("squareA5", D, n, j, e),
        tile("squareA5", D, f, i, m),
        tile("squareA5", B, l, h, f),
    ]


def deflate_squareA5(squareA5: Tile) -> list[Tile]:
    A = squareA5.points[0]
    B = squareA5.points[1]
    C = squareA5.points[2]
    D = squareA5.points[3]
    e = (C - A) / (silvRatio + 1) + A
    f = (D - B) / (silvRatio + 1) + B
    g = (A - C) / (silvRatio + 1) + C
    h = (B - D) / (silvRatio + 1) + D
    i = (B - A) / silvRatio + A
    j = (C - B) / silvRatio + B
    k = (C - D) / silvRatio + D
    l = (D - A) / silvRatio + A
    m = B + i - f
    n = C + j - g
    o = C + k - g
    p = D + l - h
    return [
        tile("squareA5", g, h, e, f),
        tile("squareA5", B, m, i, f),
        tile("squareA5", C, n, j, g),
        tile("squareA5", C, o, k, g),
        tile("squareA5", D, p, l, h),
        tile("rhombA5", A, e, h, l),
        tile("rhombA5", A, i, f, e),
        tile("rhombA5", B, j, g, f),
        tile("rhombA5", D, h, g, k),
    ]


def deflate_pent1(pent1: Tile) -> list[Tile]:
    A = pent1.points[0]
    B = pent1.points[1]
    C = pent1.points[2]
    D = pent1.points[3]
    E = pent1.points[4]
    f = (C - A) / golden_ratio + A
    g = (D - B) / golden_ratio + B
    h = (E - C) / golden_ratio + C
    i = (A - D) / golden_ratio + D
    j = (B - E) / golden_ratio + E
    k = (A - B) / golden_ratio + B
    l = (B - A) / golden_ratio + A
    m = (B - C) / golden_ratio + C
    n = (C - B) / golden_ratio + B
    o = (C - D) / golden_ratio + D
    p = (D - C) / golden_ratio + C
    q = (D - E) / golden_ratio + E
    r = (E - D) / golden_ratio + D
    s = (E - A) / golden_ratio + A
    t = (A - E) / golden_ratio + E
    return [
        tile("pent1", f, g, h, i, j),
        tile("pent2", f, j, l, B, m),
        tile("pent2", g, f, n, C, o),
        tile("pent2", h, g, p, D, q),
        tile("pent2", i, h, r, E, s),
        tile("pent2", j, i, t, A, k),
    ]


def deflate_pent2(pent2: Tile) -> list[Tile]:
    A = pent2.points[0]
    B = pent2.points[1]
    C = pent2.points[2]
    D = pent2.points[3]
    E = pent2.points[4]
    f = (C - A) / golden_ratio + A
    g = (D - B) / golden_ratio + B
    h = (E - C) / golden_ratio + C
    i = (A - D) / golden_ratio + D
    j = (B - E) / golden_ratio + E
    k = (A - B) / golden_ratio + B
    l = (B - A) / golden_ratio + A
    m = (B - C) / golden_ratio + C
    n = (C - B) / golden_ratio + B
    o = (C - D) / golden_ratio + D
    p = (D - C) / golden_ratio + C
    q = (D - E) / golden_ratio + E
    r = (E - D) / golden_ratio + D
    s = (E - A) / golden_ratio + A
    t = (A - E) / golden_ratio + E
    u = A + B - j
    v = o + p - g
    w = q + r - h
    return [
        tile("pent1", f, g, h, i, j),
        tile("pent3", j, l, B, m, f),
        tile("pent2", g, f, n, C, o),
        tile("pent2", h, g, p, D, q),
        tile("pent2", i, h, r, E, s),
        tile("pent3", k, j, i, t, A),
        tile("diamond", j, k, u, l),
        tile("diamond", g, o, v, p),
        tile("diamond", h, q, w, r),
    ]


def deflate_pent3(pent3: Tile) -> list[Tile]:
    A = pent3.points[0]
    B = pent3.points[1]
    C = pent3.points[2]
    D = pent3.points[3]
    E = pent3.points[4]
    f = (C - A) / golden_ratio + A
    g = (D - B) / golden_ratio + B
    h = (E - C) / golden_ratio + C
    i = (A - D) / golden_ratio + D
    j = (B - E) / golden_ratio + E
    k = (A - B) / golden_ratio + B
    l = (B - A) / golden_ratio + A
    m = (B - C) / golden_ratio + C
    n = (C - B) / golden_ratio + B
    o = (C - D) / golden_ratio + D
    p = (D - C) / golden_ratio + C
    q = (D - E) / golden_ratio + E
    r = (E - D) / golden_ratio + D
    s = (E - A) / golden_ratio + A
    t = (A - E) / golden_ratio + E
    u = B + C - f
    v = A + E - i
    return [
        tile("pent1", g, h, i, j, f),
        tile("pent3", m, f, j, l, B),
        tile("pent3", f, n, C, o, g),
        tile("pent2", h, g, p, D, q),
        tile("pent3", s, i, h, r, E),
        tile("pent3", i, t, A, k, j),
        tile("diamond", f, m, u, n),
        tile("diamond", i, s, v, t),
    ]


def deflate_diamond(diamond: Tile) -> list[Tile]:
    A = diamond.points[0]
    B = diamond.points[1]
    C = diamond.points[2]
    D = diamond.points[3]
    e = (A - C) / golden_ratio + C
    f = (A - B) / golden_ratio + B
    g = (B - A) / golden_ratio + A
    h = (B - C) / golden_ratio + C
    i = (C - B) / golden_ratio + B
    j = (C - D) / golden_ratio + D
    k = (D - C) / golden_ratio + C
    l = (D - A) / golden_ratio + A
    m = (A - D) / golden_ratio + D
    n = f + g - l
    o = h + i - k
    p = j + k - h
    q = l + m - g
    return [
        tile("pent3", h, k, D, e, B),
        tile("boat", k, h, o, i, C, j, p),
        tile("star", B, e, D, l, q, m, A, f, n, g),
    ]


def deflate_boat(boat: Tile) -> list[Tile]:
    A = boat.points[0]
    B = boat.points[1]
    C = boat.points[2]
    D = boat.points[3]
    E = boat.points[4]
    F = boat.points[5]
    G = boat.points[6]
    h = (A - B) / golden_ratio + B
    i = (B - A) / golden_ratio + A
    j = (B - C) / golden_ratio + C
    k = (C - B) / golden_ratio + B
    l = (C - D) / golden_ratio + D
    m = (D - C) / golden_ratio + C
    n = (D - E) / golden_ratio + E
    o = (E - D) / golden_ratio + D
    p = (E - F) / golden_ratio + F
    q = (F - E) / golden_ratio + E
    r = (F - G) / golden_ratio + G
    s = (G - F) / golden_ratio + F
    t = (G - A) / golden_ratio + A
    u = (A - G) / golden_ratio + G
    v = (A - D) / golden_ratio + D
    w = (B - F) / golden_ratio + F
    x = (D - A) / golden_ratio + A
    y = h + i - x
    z = j + k - m
    z1 = l + m - j
    z2 = n + o - q
    z3 = p + q - n
    z4 = r + s - u
    z5 = t + u - r
    return [
        tile("pent3", j, m, D, w, B),
        tile("pent3", n, q, F, x, D),
        tile("pent3", r, u, A, v, F),
        tile("boat", m, j, z, k, C, l, z1),
        tile("boat", q, n, z2, o, E, p, z3),
        tile("boat", u, r, z4, s, G, t, z5),
        tile("star", D, x, F, v, A, h, y, i, B, w),
    ]


def deflate_star(star: Tile) -> list[Tile]:
    A = star.points[0]
    B = star.points[1]
    C = star.points[2]
    D = star.points[3]
    E = star.points[4]
    F = star.points[5]
    G = star.points[6]
    H = star.points[7]
    I = star.points[8]
    J = star.points[9]
    k = (A - B) / golden_ratio + B
    l = (B - A) / golden_ratio + A
    m = (B - C) / golden_ratio + C
    n = (C - B) / golden_ratio + B
    o = (C - D) / golden_ratio + D
    p = (D - C) / golden_ratio + C
    q = (D - E) / golden_ratio + E
    r = (E - D) / golden_ratio + D
    s = (E - F) / golden_ratio + F
    t = (F - E) / golden_ratio + E
    u = (F - G) / golden_ratio + G
    v = (G - F) / golden_ratio + F
    w = (G - H) / golden_ratio + H
    x = (H - G) / golden_ratio + G
    y = (H - I) / golden_ratio + I
    z = (I - H) / golden_ratio + H
    z1 = (I - J) / golden_ratio + J
    z2 = (J - I) / golden_ratio + I
    z3 = (J - A) / golden_ratio + A
    z4 = (A - J) / golden_ratio + J
    z5 = (B - H) / golden_ratio + H
    z6 = (B - F) / golden_ratio + F
    z7 = (F - B) / golden_ratio + B
    z8 = (F - J) / golden_ratio + J
    z9 = (H - B) / golden_ratio + B
    z10 = k + l - z3
    z11 = m + n - p
    z12 = o + p - m
    z13 = q + r - t
    z14 = s + t - q
    z15 = u + v - x
    z16 = w + x - u
    z17 = y + z - z2
    z18 = z1 + z2 - y
    z19 = z3 + z4 - l
    return [
        tile("pent3", z3, l, B, z5, J),
        tile("pent3", m, p, D, z6, B),
        tile("pent3", q, t, F, z7, D),
        tile("pent3", u, x, H, z8, F),
        tile("pent3", y, z2, J, z9, H),
        tile("boat", l, z3, z19, z4, A, k, z10),
        tile("boat", p, m, z11, n, C, o, z12),
        tile("boat", t, q, z13, r, E, s, z14),
        tile("boat", x, u, z15, v, G, w, z16),
        tile("boat", z2, y, z17, z, I, z1, z18),
        tile("star", F, z8, H, z9, J, z5, B, z6, D, z7),
    ]


def defalte_tile(t: Tile) -> list[Tile]:
    match t.name:
        case "kite":
            return deflate_kite(t)
        case "dart":
            return deflate_dart(t)
        case "fat":
            return deflate_fat(t)
        case "thin":
            return deflate_thin(t)
        case "square":
            return deflate_square(t)
        case "triangle":
            return deflate_triangle(t)
        case "sierpinski":
            return deflate_sierpinski(t)
        case "hexagon":
            return deflate_hexagon(t)
        case "chair":
            return deflate_chair(t)
        case "rhombA5":
            return deflate_rhombA5(t)
        case "squareA5":
            return deflate_squareA5(t)
        case "pent1":
            return deflate_pent1(t)
        case "pent2":
            return deflate_pent2(t)
        case "pent3":
            return deflate_pent3(t)
        case "diamond":
            return deflate_diamond(t)
        case "boat":
            return deflate_boat(t)
        case "star":
            return deflate_star(t)
        case _:
            raise ValueError(f"Unexpected tile name: {t.name}")


def run_defaltion(tiles: list[Tile], iterations: int) -> list[Polygon]:
    for _ in range(iterations):
        centers: set[Point] = set()
        subtiles: list[Tile] = []
        for tile in tiles:
            for subtile in defalte_tile(tile):
                center = subtile.rounded_center()
                if center in centers:
                    continue
                subtiles.append(subtile)
                centers.add(center)
        tiles = subtiles
    return [t.as_polygon() for t in tiles]


def pent1_deflation_border_conservative() -> list[LineSegment]:
    """Inscribed 5-edge star can serve as a conservative border for P1 tiling"""
    pent_large = pent1[0].as_polygon()

    p1_1 = run_defaltion(tiles=pent1, iterations=1)
    pent_small = p1_1[0]

    points: list[Point] = []
    rot_idx = 2
    lg_vertices = list(pent_large.vertices)
    lg_vertices = lg_vertices[rot_idx:] + lg_vertices[:rot_idx]
    for sm_edge, lg_vertex in zip(pent_small.edges, lg_vertices):
        points.append(sm_edge[0])
        points.append(lg_vertex)
        points.append(sm_edge[1])

    return list(Polygon.from_points(points).edges)
