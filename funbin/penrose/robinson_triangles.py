"""
Penrose two-shape tiling (P2/P3), generated by recursive subdivision of a set of
Robinson triangles. Modeled after [1] (see also comment by Tim Hutton).

[1] https://preshing.com/20110831/penrose-tiling-explained/
"""

import cmath
import math
from typing import Literal

import numpy as np

from funbin.geometry import (
    LineSegment,
    Point,
    Polygon,
    SpatialIndex,
    are_segments_close,
)

golden_ratio = (5**0.5 + 1) / 2  # Golden ratio


PenroseBitilingKind = Literal["P2", "P3"]

TriangleKind = Literal[0, 1]  # thin, thick
Triangle = tuple[TriangleKind, complex, complex, complex]


def penrose_tiling_robinson(
    kind: PenroseBitilingKind,
    divisions: int,
    include_incomplete_tiles: bool = False,
    base_triangles: int = 5,
) -> list[Polygon]:
    tiling = robinson_triangles(kind=kind, divisions=divisions, base_triangles=base_triangles)
    index = SpatialIndex.from_polygons(tiling, bbox_resize_factor=1.05)

    merged = set[int]()
    to_merge = list[tuple[int, int]]()
    for id, triangle in enumerate(tiling):
        if id in merged:
            continue
        *_, edge_1 = triangle.edges  # last edge is to be merged
        for other_id, other in index.candidate_tiles(edge_1[0]):
            if other_id == id or other_id in merged:
                continue
            *_, edge_2 = other.edges  # last edge is to be merged
            if are_segments_close(edge_1, edge_2):
                merged.add(id)
                merged.add(other_id)
                to_merge.append((id, other_id))
                break

    res: list[Polygon] = []
    for id1, id2 in to_merge:
        res.append(
            Polygon(
                verts=np.concatenate(
                    (
                        tiling[id1].verts,
                        [tiling[id2].verts[1, :]],
                    )
                )
            )
        )

    if include_incomplete_tiles:
        for id, tile in enumerate(tiling):
            if id not in merged:
                res.append(tile)

    return res


def robinson_triangles(kind: PenroseBitilingKind, divisions: int, base_triangles: int = 5) -> list[Polygon]:
    # Create first layer of triangles
    triangles: list[Triangle] = []
    for i in range(base_triangles * 2):
        v2 = cmath.rect(1, (2 * i - 1) * math.pi / (base_triangles * 2))
        v3 = cmath.rect(1, (2 * i + 1) * math.pi / (base_triangles * 2))
        if i % 2 == 0:
            v2, v3 = v3, v2  # Mirror every other triangle

        if kind == "P2":
            triangles.append((0, v2, 0j, v3))
        else:
            triangles.append((0, 0, v2, v3))

    for i in range(divisions):
        new_triangles: list[Triangle] = []
        for shape, v1, v2, v3 in triangles:
            if kind == "P2":
                if shape == 0:
                    # Subdivide red (sharp isosceles) (half kite) triangle
                    p1 = v1 + (v2 - v1) / golden_ratio
                    p2 = v2 + (v3 - v2) / golden_ratio
                    new_triangles.extend(((1, p2, p1, v2), (0, p1, v1, p2), (0, v3, v1, p2)))
                else:
                    # Subdivide blue (fat isosceles) (half dart) triangle
                    p3 = v3 + (v1 - v3) / golden_ratio
                    new_triangles.extend(((1, v2, p3, v1), (0, p3, v3, v2)))
            else:
                if shape == 0:
                    # Divide thin rhombus
                    p1 = v1 + (v2 - v1) / golden_ratio
                    new_triangles.extend(((1, p1, v3, v1), (0, v3, p1, v2)))
                else:
                    # Divide thicc rhombus
                    p2 = v2 + (v1 - v2) / golden_ratio
                    p3 = v2 + (v3 - v2) / golden_ratio
                    new_triangles.extend(((1, p3, v3, v1), (1, p2, p3, v2), (0, p3, p2, v1)))

        triangles = new_triangles

    return [
        Polygon.from_points(
            (
                Point.from_complex(v2),
                Point.from_complex(v1),
                Point.from_complex(v3),
                # NOTE: in the original script the closing edge of the triangle (v3 -> v2)
                # is never drawn. here we save it so that the "missing" closing edge is last
                # we use it later when merging triangles into tiles
            )
        )
        for _, v1, v2, v3 in triangles
    ]


def robinson_triangles_border() -> list[LineSegment]:
    return [list(tri.edges)[2] for tri in robinson_triangles(kind="P3", divisions=0)]
